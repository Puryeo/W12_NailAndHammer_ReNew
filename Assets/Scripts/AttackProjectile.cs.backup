using System.Collections;
using UnityEngine;

/// <summary>
/// AttackProjectile (ë±€íŒŒì´ì–´ í—Œí„° Ver.)
/// ì—­í• : íˆ¬ì‚¬ì²´ì˜ ì´ë™, ì¶©ëŒ íŒë³„, ë²½ ë°•í˜(Stick), ì‚¬ìŠ¬ íšŒìˆ˜(Retrieval) ë° ê²½ë¡œ íƒ€ê²© ì²˜ë¦¬
/// </summary>
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(Collider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public class AttackProjectile : MonoBehaviour
{
    [Header("General Settings")]
    [Tooltip("ë²½ì— ë°•í˜”ì„ ë•Œ ìœ ì§€ë  ì‹œê°„ (0 = ë¬´í•œ)")]
    [SerializeField] private float stuckLifetime = 0f;

    [Tooltip("ì´ íˆ¬ì‚¬ì²´ê°€ íšŒìˆ˜ ê°€ëŠ¥í•œ íƒ€ì…(ë‚˜ë¬´ ë§ëš)ì¸ì§€ ì—¬ë¶€")]
    [SerializeField] private bool isRetrievable = true;

    [Header("Return Settings")]
    [Tooltip("íšŒìˆ˜ ì‹œ ë˜ëŒì•„ì˜¤ëŠ” ì†ë„")]
    [SerializeField] private float returnSpeed = 20f;
    [Tooltip("íšŒìˆ˜ ì‹œ ê²½ë¡œìƒì˜ ì ì—ê²Œ ì…íˆëŠ” ëŒ€ë¯¸ì§€ ë¹„ìœ¨ (1.0 = 100%)")]
    [SerializeField] private float returnDamageRatio = 0.5f;
    [Tooltip("í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ë¡œ í¡ìˆ˜ íŒë‹¨ (ì¶©ëŒ ì‹¤íŒ¨ ë³´ì™„)")]
    [SerializeField] private float pickupDistance = 0.65f;

    [Header("Hit Feedback Settings (Inspector)")]
    [Tooltip("ì ì¤‘(ì§ì ‘ íˆíŠ¸) ì‹œ ì ìš©í•  íˆíŠ¸ìŠ¤íƒ‘ ê°•ë„")]
    [SerializeField] private global::EHitStopStrength hitStopOnEnemyHit = global::EHitStopStrength.Weak;
    [Tooltip("ì ì¤‘(ì§ì ‘ íˆíŠ¸) ì‹œ ì ìš©í•  ì¹´ë©”ë¼ ì…°ì´í¬ ê°•ë„")]
    [SerializeField] private global::EShakeStrength shakeOnEnemyHit = global::EShakeStrength.Weak;
    [Tooltip("íšŒìˆ˜(ë¦¬í„´) ê²½ë¡œìƒ ì ì¤‘ ì‹œ ì ìš©í•  íˆíŠ¸ìŠ¤íƒ‘ ê°•ë„")]
    [SerializeField] private global::EHitStopStrength hitStopOnReturnHit = global::EHitStopStrength.Weak;
    [Tooltip("íšŒìˆ˜(ë¦¬í„´) ê²½ë¡œìƒ ì ì¤‘ ì‹œ ì ìš©í•  ì¹´ë©”ë¼ ì…°ì´í¬ ê°•ë„")]
    [SerializeField] private global::EShakeStrength shakeOnReturnHit = global::EShakeStrength.Weak;

    [Header("Auto Retrieve (Wall)")]
    [Tooltip("ë²½ì— ë°•íŒ ë§ëšì„ ìë™ íšŒìˆ˜í•˜ê¸° ìœ„í•œ ë°˜ê²½ (í”Œë ˆì´ì–´ê°€ ë°˜ê²½ ë‚´ë¡œ ë“¤ì–´ì˜¤ë©´ ìë™ íšŒìˆ˜ ì‹œì‘)")]
    [SerializeField] private float autoRetrieveRange = 3f;

    // ë‚´ë¶€ ë°ì´í„°
    private AttackPatternData pattern;
    private float damage;
    private string targetTag;    // ì  íƒœê·¸ (ì˜ˆ: "Enemy")
    private string wallTag = "Wall";
    private Transform attacker;  // ë°œì‚¬í•œ ì£¼ì²´ (í”Œë ˆì´ì–´)

    // BloodStake ê´€ë ¨
    private bool isBloodStake = false;
    private float bloodHpCost = 0f;

    // ì»´í¬ë„ŒíŠ¸
    private Rigidbody2D rb2D;
    private Collider2D col2D;
    private SpriteRenderer spriteRenderer;

    // ìƒíƒœ í”Œë˜ê·¸
    private bool isInitialized = false;
    private bool isStuck = false;      // ë²½/ì ì— ë°•í˜€ìˆëŠ”ê°€?
    private bool isReturning = false;  // íšŒìˆ˜ ì¤‘ì¸ê°€?
    private float lifeTimer;

    // ìºì‹±
    private CameraShake cameraShake; // í”¼ê²©ê°ì„ ìœ„í•œ ì¹´ë©”ë¼ ì…°ì´í¬

    // í˜„ì¬ ë¶€ì°©(host) ì¤‘ì¸ EnemyController (ìˆìœ¼ë©´ ì ì—ê²Œ ë°•í˜€ ìˆìŒ)
    private EnemyController currentHostEnemy;

    // Host transform (ì  ë˜ëŠ” ë²½ íŠ¸ëœìŠ¤í¼). ë¶€ëª¨ë¡œ ë¶™ì´ì§€ ì•Šê³  ìœ„ì¹˜/íšŒì „ì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ ì‚¬ìš©
    private Transform stuckHostTransform;
    private Vector3 stuckLocalPosition;      // host ê¸°ì¤€ ë¡œì»¬ í¬ì§€ì…˜
    private Quaternion stuckLocalRotation;   // host ê¸°ì¤€ ë¡œì»¬ íšŒì „ (ìƒëŒ€ íšŒì „)

    // í”Œë ˆì´ì–´ ìºì‹œ (ìë™ íšŒìˆ˜ ë²”ìœ„ ê²€ì‚¬ì— ì‚¬ìš©)
    private Transform playerTransform;

    // ì›ë˜ ë¡œì»¬ ìŠ¤ì¼€ì¼(í’€ ì¬ì‚¬ìš© ì‹œ ë³µì›ìš©)
    private Vector3 originalLocalScale;

    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = false;

    // íšŒìˆ˜/ì¤‘ë³µ ë°©ì§€
    private bool suppressAmmoOnReturn = false;
    private bool hasBeenCollected = false;

    private void Awake()
    {
        rb2D = GetComponent<Rigidbody2D>();
        col2D = GetComponent<Collider2D>();
        spriteRenderer = GetComponent<SpriteRenderer>();

        if (Camera.main != null) cameraShake = Camera.main.GetComponent<CameraShake>();

        var playerObj = GameObject.FindGameObjectWithTag("Player");
        if (playerObj != null) playerTransform = playerObj.transform;

        originalLocalScale = transform.localScale;
    }

    /// <summary>
    /// íˆ¬ì‚¬ì²´ ì´ˆê¸°í™” (AttackManagerì—ì„œ í˜¸ì¶œ)
    /// </summary>
    public void Initialize(
        AttackPatternData pattern,
        float damage,
        string targetTag,
        Transform attacker,
        Color? overrideColor = null,
        Vector2? overrideDirection = null,
        bool isBloodStake = false,
        float bloodHpCost = 0f)
    {
        this.pattern = pattern;
        this.damage = damage;
        this.targetTag = targetTag;
        this.attacker = attacker;

        // Blood ì •ë³´ ë³´ì¡´
        this.isBloodStake = isBloodStake;
        this.bloodHpCost = bloodHpCost;

        // Collider ì´ˆê¸°í™”
        if (col2D != null) col2D.isTrigger = true;

        if (pattern != null && spriteRenderer != null && pattern.attackSprite != null)
            spriteRenderer.sprite = pattern.attackSprite;

        if (overrideColor.HasValue && spriteRenderer != null)
            spriteRenderer.color = overrideColor.Value;

        // ë¬¼ë¦¬ ì•ˆì „ ì´ˆê¸°í™”
        rb2D.gravityScale = 0f;
        rb2D.linearDamping = 0f;
        rb2D.angularDamping = 0f;

        currentHostEnemy = null;
        stuckHostTransform = null;
        isStuck = false;
        isReturning = false;
        suppressAmmoOnReturn = false;
        hasBeenCollected = false;

        // ë³µì›í•  ìŠ¤ì¼€ì¼ ë³´ì¥
        transform.localScale = originalLocalScale;

        // ì¸ìŠ¤í„´ìŠ¤ëŠ” íŒ¨í„´ ê¸°ë°˜ìœ¼ë¡œ retrievable ì„¤ì •ì„ ë®ì–´ì“´ë‹¤
        if (pattern != null)
        {
            this.isRetrievable = pattern.isRetrievable;
        }

        if (pattern != null)
        {
            if (pattern.attackType == EAttackType.Projectile)
            {
                rb2D.bodyType = RigidbodyType2D.Dynamic;

                Vector2 direction = overrideDirection ?? (attacker != null ? (Vector2)attacker.right : Vector2.right);
                if (direction == Vector2.zero) direction = Vector2.right;
                direction.Normalize();

                float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
                transform.rotation = Quaternion.Euler(0, 0, angle);

                rb2D.linearVelocity = direction * pattern.projectileSpeed;
                lifeTimer = pattern.projectileLifetime;
            }
            else if (pattern.attackType == EAttackType.MeleeSlash)
            {
                rb2D.bodyType = RigidbodyType2D.Kinematic;
                transform.SetParent(attacker);
                transform.localPosition = pattern.hitboxOffset;
                lifeTimer = pattern.attackDuration;
            }
        }

        isInitialized = true;
    }

    private void Update()
    {
        if (!isInitialized) return;

        // ë°•íŒ ìƒíƒœ & hostê°€ ìˆìœ¼ë©´ hostë¥¼ ë”°ë¼ ìœ„ì¹˜/íšŒì „ ì—…ë°ì´íŠ¸
        if (isStuck && !isReturning && stuckHostTransform != null)
        {
            // hostê°€ íŒŒê´´ë˜ì—ˆìœ¼ë©´ ë¶„ë¦¬
            if (stuckHostTransform == null)
            {
                ForceDetachFromHost();
                return;
            }

            // host ê¸°ì¤€ ë¡œì»¬ ì¢Œí‘œë¥¼ ì›”ë“œë¡œ ë³€í™˜í•˜ì—¬ ìœ„ì¹˜/íšŒì „ ìœ ì§€(ë¶€ëª¨ ìŠ¤ì¼€ì¼ ì˜í–¥ ì—†ìŒ)
            transform.position = stuckHostTransform.TransformPoint(stuckLocalPosition);
            transform.rotation = stuckHostTransform.rotation * stuckLocalRotation;

            // ìë™ íšŒìˆ˜ (ë²½ì— ë°•í˜”ì„ ë•Œ hostê°€ wall íƒœê·¸ë¼ë©´ player ê±°ë¦¬ ì²´í¬)
            if (stuckHostTransform.CompareTag(wallTag))
            {
                if (playerTransform == null)
                {
                    var p = GameObject.FindGameObjectWithTag("Player");
                    if (p != null) playerTransform = p.transform;
                }

                if (playerTransform != null)
                {
                    float dist = Vector2.Distance(playerTransform.position, transform.position);
                    if (dist <= autoRetrieveRange)
                    {
                        if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: ìë™ íšŒìˆ˜ ë²”ìœ„ ì§„ì…");
                        StartReturn();
                        return;
                    }
                }
            }

            if (stuckLifetime > 0f)
            {
                lifeTimer -= Time.deltaTime;
                if (lifeTimer <= 0) DissolveAndDestroy();
            }

            return;
        }

        if (isReturning)
        {
            if (attacker == null)
            {
                if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: isReturning but attacker==null -> ReturnOrDestroy");
                ReturnOrDestroy();
                return;
            }

            // ê±°ë¦¬ ê¸°ë°˜ í¡ìˆ˜: ì¶©ëŒ ë¯¸ê²€ì¶œë¡œ ì¸í•œ ëˆ„ìˆ˜ ë°©ì§€
            float sqr = (attacker.position - transform.position).sqrMagnitude;
            if (sqr <= pickupDistance * pickupDistance)
            {
                if (!hasBeenCollected)
                {
                    if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: Auto-pickup by attacker (dist={Mathf.Sqrt(sqr):F2})");
                    // ì¦‰ì‹œ ìˆ˜ì§‘
                    CompleteRetrieval();
                    return;
                }
            }

            // ê¸°ë³¸ íšŒìˆ˜ ì´ë™
            Vector2 dir = (attacker.position - transform.position).normalized;
            transform.Translate(dir * returnSpeed * Time.deltaTime, Space.World);

            float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.Euler(0, 0, angle);
            return;
        }

        if (isStuck)
        {
            if (stuckLifetime > 0f)
            {
                lifeTimer -= Time.deltaTime;
                if (lifeTimer <= 0) DissolveAndDestroy();
            }
            return;
        }

        lifeTimer -= Time.deltaTime;
        if (lifeTimer <= 0) ReturnOrDestroy();
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (!isInitialized) return;

        // ìœ í‹¸: íƒœê·¸ ê²€ì‚¬ ì‹¤íŒ¨ ì‹œ ë¶€ëª¨ì—ì„œ EnemyControllerê°€ ìˆìœ¼ë©´ ì ìœ¼ë¡œ ì·¨ê¸‰
        bool IsTargetMatch(Collider2D col)
        {
            if (string.IsNullOrEmpty(targetTag) == false && col.CompareTag(targetTag)) return true;
            return col.GetComponentInParent<EnemyController>() != null;
        }

        // ë³€ê²½: ì´ë¯¸ ë°•íŒ ë§ëš(stuck)ì¸ ê²½ìš°, ë‹¤ë¥¸ ì¶©ëŒ(ì ì˜ ê³µê²© ë“±)ìœ¼ë¡œ ì¸í•´ ì˜ëª» íšŒìˆ˜ë˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´
        // isStuck && !isReturning ìƒíƒœì—ì„œëŠ” íŠ¸ë¦¬ê±°ë¥¼ ë¬´ì‹œí•œë‹¤.
        if (isStuck && !isReturning)
        {
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: ì¶©ëŒ ë¬´ì‹œ (isStuck && !isReturning) other={other.name} tag={other.tag}");
            return;
        }

        // Friendly-fire ë°©ì§€: ë°œì‚¬ìê°€ ì (EnemyController ë³´ìœ )ì´ê³  ì¶©ëŒ ëŒ€ìƒë„ ì ì´ë©´ ë¬´ì‹œ
        var otherEnemy = other.GetComponentInParent<EnemyController>();
        var attackerEnemy = attacker != null ? attacker.GetComponentInParent<EnemyController>() : null;
        if (attackerEnemy != null && otherEnemy != null)
        {
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: Friendly fire ignored (attacker={attackerEnemy.name}, target={otherEnemy.name})");
            return;
        }

        // íšŒìˆ˜ ì¤‘
        if (isReturning)
        {
            // í”Œë ˆì´ì–´ ë„ì°©
            if (attacker != null && (other.transform == attacker || other.transform.IsChildOf(attacker)))
            {
                CompleteRetrieval();
                return;
            }

            // íšŒìˆ˜ ê²½ë¡œìƒ ì  íˆíŠ¸
            if (IsTargetMatch(other))
            {
                if (!(attacker != null && (other.transform == attacker || other.transform.IsChildOf(attacker))))
                {
                    ApplyDamageAndEffects(other, returnDamageRatio);
                    ApplyHitFeedback(hitStopOnReturnHit, shakeOnReturnHit);
                }
                return;
            }

            return;
        }

        // ë°œì‚¬ ì¤‘
        if (other.CompareTag(wallTag))
        {
            if (pattern != null && pattern.attackType == EAttackType.Projectile && isRetrievable && !isStuck)
            {
                StickToWall(other);
            }
            else if (!isRetrievable)
            {
                ReturnOrDestroy();
            }
            return;
        }

        if (IsTargetMatch(other))
        {
            // ë°œì‚¬ì(í”Œë ˆì´ì–´)ì— ë¶™ëŠ” ë¬¸ì œ ë°©ì§€
            if (attacker != null && (other.transform == attacker || other.transform.IsChildOf(attacker))) return;

            ApplyDamageAndEffects(other, 1.0f);
            ApplyHitFeedback(hitStopOnEnemyHit, shakeOnEnemyHit);

            if (pattern != null && pattern.attackType == EAttackType.Projectile && isRetrievable && !isStuck)
            {
                StickToEnemy(other);
            }
            else
            {
                ReturnOrDestroy();
            }
        }
    }

    private void SetParentPreserveWorld(Transform newParent)
    {
        if (newParent == null) { transform.SetParent(null); return; }

        Vector3 worldPos = transform.position;
        Quaternion worldRot = transform.rotation;
        Vector3 worldScale = new Vector3(transform.lossyScale.x, transform.lossyScale.y, transform.lossyScale.z);

        transform.SetParent(newParent, true);

        Vector3 parentScale = newParent.lossyScale;
        parentScale.x = Mathf.Abs(parentScale.x) < 1e-6f ? 1f : parentScale.x;
        parentScale.y = Mathf.Abs(parentScale.y) < 1e-6f ? 1f : parentScale.y;
        parentScale.z = Mathf.Abs(parentScale.z) < 1e-6f ? 1f : parentScale.z;

        Vector3 localScale = new Vector3(
            worldScale.x / parentScale.x,
            worldScale.y / parentScale.y,
            worldScale.z / parentScale.z
        );

        localScale.x = float.IsNaN(localScale.x) ? 1f : Mathf.Clamp(localScale.x, 0.01f, 10f);
        localScale.y = float.IsNaN(localScale.y) ? 1f : Mathf.Clamp(localScale.y, 0.01f, 10f);
        localScale.z = float.IsNaN(localScale.z) ? 1f : Mathf.Clamp(localScale.z, 0.01f, 10f);

        transform.localScale = localScale;

        transform.position = worldPos;
        transform.rotation = worldRot;
    }

    private void AttachToColliderWithScale(Collider2D hitCollider)
    {
        if (hitCollider == null) return;

        Vector2 contactWorld = hitCollider.ClosestPoint(transform.position);
        Vector2 offsetDir = ((Vector2)transform.position - contactWorld);
        if (offsetDir.sqrMagnitude > 1e-6f) offsetDir = offsetDir.normalized;
        else offsetDir = (Vector2)transform.right;

        float baseOffset = 0.02f;
        float sizeBased = baseOffset;
        if (spriteRenderer != null)
        {
            sizeBased = Mathf.Max(sizeBased, spriteRenderer.bounds.extents.magnitude * 0.08f);
        }
        else if (col2D != null)
        {
            sizeBased = Mathf.Max(sizeBased, col2D.bounds.extents.magnitude * 0.08f);
        }

        Vector3 worldPos = contactWorld + offsetDir * sizeBased;
        Quaternion worldRot = transform.rotation;

        stuckHostTransform = hitCollider.transform;
        stuckLocalPosition = stuckHostTransform.InverseTransformPoint(worldPos);
        stuckLocalRotation = Quaternion.Inverse(stuckHostTransform.rotation) * worldRot;

        transform.SetParent(null);
        transform.position = worldPos;
        transform.rotation = worldRot;

        transform.localScale = originalLocalScale;
    }

    private void StickToWall(Collider2D wallCollider)
    {
        if (isStuck) return;
        isStuck = true;

        if (showDebugLogs) Debug.Log($"ğŸ“Œ {gameObject.name} ë²½ì— ë°•í˜!");

        rb2D.linearVelocity = Vector2.zero;
        rb2D.angularVelocity = 0f;
        rb2D.bodyType = RigidbodyType2D.Static;

        if (spriteRenderer != null) spriteRenderer.color = new Color(0.7f, 0.7f, 0.7f, 1f);

        AttachToColliderWithScale(wallCollider);

        lifeTimer = stuckLifetime;

        if (cameraShake != null) cameraShake.ShakeWeak();
    }

    private void StickToEnemy(Collider2D enemyCollider)
    {
        if (isStuck) return;
        isStuck = true;

        if (showDebugLogs) Debug.Log($"ğŸ“Œ {gameObject.name} ì ì— ë°•í˜!");

        rb2D.linearVelocity = Vector2.zero;
        rb2D.angularVelocity = 0f;
        rb2D.bodyType = RigidbodyType2D.Static;

        if (spriteRenderer != null) spriteRenderer.color = new Color(0.7f, 0.7f, 0.7f, 1f);

        AttachToColliderWithScale(enemyCollider);

        EnemyController enemyCtrl = enemyCollider.GetComponent<EnemyController>() ?? enemyCollider.GetComponentInParent<EnemyController>();
        if (enemyCtrl != null)
        {
            currentHostEnemy = enemyCtrl;
            enemyCtrl.RegisterStuckProjectile(this);
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: Registered to enemy {enemyCtrl.name} id={GetInstanceID()} active={gameObject.activeInHierarchy}");
        }

        lifeTimer = stuckLifetime;

        if (cameraShake != null) cameraShake.ShakeWeak();
    }

    /// <summary>
    /// íšŒìˆ˜ ì‹œì‘ (suppressAmmo: CompleteRetrieval ì‹œ ammo íšŒë³µì„ í•˜ì§€ ì•ŠìŒ)
    /// - ì´ì œ isStuck ì—¬ë¶€ì— ìƒê´€ì—†ì´ ê°•ì œ íšŒìˆ˜ ì‹œì‘ ê°€ëŠ¥
    /// - usePickupAnimation=trueë©´ í”Œë ˆì´ì–´ë¡œ ëŒì–´ì˜¤ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ì¬ìƒ
    /// </summary>
    public void StartReturn(bool suppressAmmo = false, bool immediatePickup = true)
    {
        if (isReturning)
        {
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: StartReturn í˜¸ì¶œë˜ì—ˆìœ¼ë‚˜ ì´ë¯¸ isReturning=true");
            return;
        }

        // ì•ˆì „: í˜„ì¬ hostì— ë“±ë¡ë˜ì–´ ìˆìœ¼ë©´ unregister (ì¤‘ë³µ ì œê±° ë°©ì§€)
        UnregisterFromHost();

        // ìƒíƒœ ë³€ê²½
        isStuck = false;
        isReturning = true;
        suppressAmmoOnReturn = suppressAmmo;
        hasBeenCollected = false;

        if (showDebugLogs) Debug.Log($"â›“ï¸ {gameObject.name} ë§ëš íšŒìˆ˜ ì‹œì‘ (StartReturn) suppress={suppressAmmo}, immediate={immediatePickup}, id={GetInstanceID()}, attacker={(attacker!=null?attacker.name:"null")} active={gameObject.activeInHierarchy}");

        stuckHostTransform = null;
        transform.SetParent(null);

        // ë¬¼ë¦¬/ì¶©ëŒ ì„¤ì •: íšŒìˆ˜ìš©ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì „í™˜
        if (rb2D != null)
        {
            rb2D.bodyType = RigidbodyType2D.Kinematic;
            rb2D.linearVelocity = Vector2.zero;
            rb2D.angularVelocity = 0f;
        }

        if (col2D != null)
        {
            col2D.enabled = true;
            col2D.isTrigger = true;
        }

        // attacker fallback: ìºì‹œëœ playerTransform ë˜ëŠ” ì”¬ì—ì„œ Player íƒœê·¸ë¡œ ì°¾ê¸°
        if (attacker == null)
        {
            if (playerTransform != null) attacker = playerTransform;
            else
            {
                var p = GameObject.FindGameObjectWithTag("Player");
                if (p != null) { attacker = p.transform; playerTransform = attacker; }
            }
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: StartReturn attacker fallback -> {(attacker!=null?attacker.name:"null")}");
        }

        transform.localScale = originalLocalScale;
        if (spriteRenderer != null) spriteRenderer.color = Color.white;

        // immediatePickup == true ì¼ ë•Œë§Œ ì¦‰ì‹œ í…”ë ˆí¬íŠ¸ + ì¦‰ì‹œ CompleteRetrieval
        if (immediatePickup)
        {
            if (attacker != null)
            {
                transform.position = attacker.position;
                transform.rotation = attacker.rotation;
                CompleteRetrieval();
            }
            else
            {
                // attackerê°€ ì—†ìœ¼ë©´ ReturnOrDestroy ë¡œì§ìœ¼ë¡œ ì•ˆì „íˆ ì²˜ë¦¬
                ReturnOrDestroy();
            }
        }
        // immediatePickup == false ë©´ isReturning í”Œë˜ê·¸ë¥¼ ì„¸ìš´ ì±„ë¡œ Update() ë£¨í‹´ì—ì„œ ì´ë™/í¡ìˆ˜ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§
    }

    private void CompleteRetrieval()
    {
        if (hasBeenCollected) return;
        hasBeenCollected = true;
        isReturning = false;

        if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: CompleteRetrieval called. attacker={(attacker!=null?attacker.name:"null")}, suppressAmmo={suppressAmmoOnReturn}");

        PlayerCombat pc = null;

        if (attacker != null)
        {
            pc = attacker.GetComponent<PlayerCombat>();
        }

        if (pc == null)
        {
            var playerObj = GameObject.FindGameObjectWithTag("Player");
            if (playerObj != null) pc = playerObj.GetComponent<PlayerCombat>();
        }

        if (pc != null)
        {
            if (isBloodStake)
            {
                // BloodStake: íšŒìˆ˜ ì‹œ ì‚¬ìš©í•œ HPë¥¼ 100% íšŒë³µ(ìš”êµ¬ì‚¬í•­ B)
                pc.OnExecutionSuccess(bloodHpCost, 0);
                if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: BloodStake collected -> healed {bloodHpCost} HP (player={pc.name})");
            }
            else
            {
                if (!suppressAmmoOnReturn)
                {
                    pc.RecoverAmmo(1);
                    if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: CompleteRetrieval -> player recovered 1 ammo (player={pc.name})");
                }
                else
                {
                    if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: CompleteRetrieval -> suppressAmmoOnReturn==true, ammo not recovered");
                }
            }
        }
        else
        {
            if (showDebugLogs) Debug.LogWarning($"AttackProjectile [{gameObject.name}]: CompleteRetrieval -> PlayerCombat not found, ammo/HP not recovered");
        }

        UnregisterFromHost();

        if (AttackManager.Instance != null) AttackManager.Instance.ReleaseStake(gameObject);
        else Destroy(gameObject);
    }

    public void ForceDetachFromHost()
    {
        currentHostEnemy = null;
        stuckHostTransform = null;
        transform.SetParent(null);

        isStuck = false;
        isReturning = false;

        if (rb2D != null) rb2D.bodyType = RigidbodyType2D.Kinematic;
        if (col2D != null) col2D.isTrigger = true;
        if (spriteRenderer != null) spriteRenderer.color = Color.white;

        transform.localScale = originalLocalScale;
    }

    private void UnregisterFromHost()
    {
        if (currentHostEnemy != null)
        {
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: UnregisterFromHost -> removing from {currentHostEnemy.name} id={GetInstanceID()}");
            currentHostEnemy.RemoveStuckProjectile(this);
            currentHostEnemy = null;
        }
        else
        {
            if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: UnregisterFromHost -> no currentHostEnemy id={GetInstanceID()}");
        }
    }

    private void ApplyDamageAndEffects(Collider2D target, float damageRatio)
    {
        float finalDamage = damage * damageRatio;

        HealthSystem hs = target.GetComponent<HealthSystem>() ?? target.GetComponentInParent<HealthSystem>();
        if (hs != null)
        {
            hs.TakeDamage(finalDamage);
        }
        else
        {
            var damageable = target.GetComponent<IDamageable>() ?? target.GetComponentInParent<IDamageable>();
            if (damageable != null) damageable.TakeDamage(finalDamage);
        }

        var enemyCtrl = target.GetComponent<EnemyController>() ?? target.GetComponentInParent<EnemyController>();
        if (enemyCtrl != null)
        {
            enemyCtrl.RegisterHit(1, attacker);
        }

        if (!isReturning && pattern != null)
        {
            if (pattern.stunDuration > 0)
            {
                IStunnable stunnable = target.GetComponent<IStunnable>() ?? target.GetComponentInParent<IStunnable>();
                if (stunnable != null) stunnable.ApplyStun(pattern.stunDuration);
            }

            if (pattern.knockbackStrength != EKnockbackStrength.None)
            {
                Rigidbody2D targetRb = target.GetComponent<Rigidbody2D>() ?? target.GetComponentInParent<Rigidbody2D>();
                if (targetRb != null)
                {
                    Vector2 knockbackDir;
                    if (targetRb.transform != null)
                        knockbackDir = (targetRb.transform.position - transform.position).normalized;
                    else
                        knockbackDir = (target.transform.position - transform.position).normalized;

                    float force = Mathf.Max(0f, pattern.knockbackDistance) * 5f;
                    switch (pattern.knockbackStrength)
                    {
                        case EKnockbackStrength.Weak: force *= 0.8f; break;
                        case EKnockbackStrength.Small: force *= 1.0f; break;
                        case EKnockbackStrength.Medium: force *= 1.6f; break;
                        case EKnockbackStrength.Strong: force *= 2.6f; break;
                    }

                    targetRb.AddForce(knockbackDir * force, ForceMode2D.Impulse);
                }
            }

            if (cameraShake != null) cameraShake.ShakeWeak();
        }
    }

    private void ApplyHitFeedback(global::EHitStopStrength hs, global::EShakeStrength ss)
    {
        HitEffectManager.PlayHitEffect(EHitSource.Stake, hs, ss, transform.position);
    }

    private void DissolveAndDestroy()
    {
        UnregisterFromHost();

        if (AttackManager.Instance != null) AttackManager.Instance.ReleaseStake(gameObject);
        else Destroy(gameObject);
    }

    private void ReturnOrDestroy()
    {
        if (showDebugLogs) Debug.Log($"AttackProjectile [{gameObject.name}]: ReturnOrDestroy called (isReturning={isReturning}, isStuck={isStuck}) id={GetInstanceID()}");
        UnregisterFromHost();

        if (AttackManager.Instance != null) AttackManager.Instance.ReleaseStake(gameObject);
        else Destroy(gameObject);
    }

    public void ClearAttacker()
    {
        attacker = null;
    }

    public System.Collections.IEnumerator RetrievalAnimationRoutine(
        Transform collector,
        float pullDistance = 0.6f,
        float hitStopSeconds = 0.1f,
        float moveToPlayerDuration = 0.25f,
        LineRenderer linePrefab = null,
        global::EHitStopStrength hitStop = global::EHitStopStrength.Weak,
        global::EShakeStrength shake = global::EShakeStrength.Weak,
        GameObject endDecorator = null) // ì¶”ê°€ëœ íŒŒë¼ë¯¸í„° (ì˜µì…˜)
    {
        if (collector == null)
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: abort - collector==null");
            yield break;
        }

        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: START. collector={collector.name} active={gameObject.activeInHierarchy}");

        // ì•ˆì „ í•´ì œ: host ë“±ë¡ í•´ì œ
        UnregisterFromHost();
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: UnregisterFromHost called. currentHostEnemy={(currentHostEnemy!=null?currentHostEnemy.name:"null")}");

        isStuck = false;
        isReturning = false;
        suppressAmmoOnReturn = false;
        hasBeenCollected = false;

        attacker = collector; // CompleteRetrieval ì‹œ ë³´ìƒ ëŒ€ìƒ
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: attacker set to {attacker.name}");

        if (rb2D != null) rb2D.bodyType = RigidbodyType2D.Kinematic;
        if (col2D != null) { col2D.enabled = false; col2D.isTrigger = true; }

        Vector3 startPos = transform.position;
        Quaternion startRot = transform.rotation;
        Vector3 dirToPlayer = (collector.position - startPos).normalized;
        if (dirToPlayer == Vector3.zero) dirToPlayer = transform.right;
        Vector3 pullPos = startPos + dirToPlayer * pullDistance;

        // LineRenderer ì¤€ë¹„
        LineRenderer lr = null;
        GameObject lrGo = null;
        if (linePrefab != null)
        {
            // linePrefabì´ ì”¬ ì¸ìŠ¤í„´ìŠ¤ì¸ì§€(ì´ë¯¸ Instantiateëœ ê°ì²´) íŒë³„
            bool isSceneInstance = false;
            try
            {
                isSceneInstance = linePrefab.gameObject.scene.IsValid();
            }
            catch { isSceneInstance = false; }

            if (isSceneInstance)
            {
                // ì´ë¯¸ Skillì—ì„œ Instantiateí•œ ì¸ìŠ¤í„´ìŠ¤ê°€ ì „ë‹¬ëœ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
                lr = linePrefab;
                lrGo = lr.gameObject;
                if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: using provided LineRenderer instance {lrGo.name}");
            }
            else
            {
                // í”„ë¦¬íŒ¹ ì—ì…‹ì´ ì „ë‹¬ëœ ê²½ìš°ì—” ìƒˆë¡œ Instantiate
                lr = Instantiate(linePrefab);
                lrGo = lr?.gameObject;
                if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: instantiated LineRenderer from prefab {lrGo?.name}");
            }
        }
        else
        {
            // ëŸ°íƒ€ì„ ìƒì„±(í”„ë¦¬íŒ¹/ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ì„ ë•Œ)
            lrGo = new GameObject($"RetrievalLine_{gameObject.name}");
            lr = lrGo.AddComponent<LineRenderer>();
            lr.material = new Material(Shader.Find("Sprites/Default"));
            lr.positionCount = 2;
            lr.startWidth = lr.endWidth = 0.05f;
            lr.numCapVertices = 4;
            lr.useWorldSpace = true;
            lr.sortingOrder = 1000;
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: created runtime LineRenderer {lrGo.name}");
        }

        // ì•ˆì „ ì´ˆê¸°í™”
        if (lr != null)
        {
            lr.positionCount = 2;
            lr.useWorldSpace = true;
            // set starting positions: [0]=collector, [1]=stake
            lr.SetPosition(0, collector.position);
            lr.SetPosition(1, transform.position);
        }

        // end decorator (ì„  ë ì¥ì‹) - ì¶”ê°€
        GameObject endDec = null;
        if (endDecorator != null)
        {
            try
            {
                endDec = Instantiate(endDecorator, transform.position, transform.rotation);
                if (endDec != null)
                {
                    endDec.SetActive(true);
                    // ë³´ì´ë„ë¡ ì •ë ¬ ë³´ì • ì‹œë„
                    var sr = endDec.GetComponent<SpriteRenderer>() ?? endDec.GetComponentInChildren<SpriteRenderer>();
                    if (sr != null) sr.sortingOrder = Mathf.Max(sr.sortingOrder, 1001);
                }
                if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: instantiated endDecorator {endDec?.name}");
            }
            catch (System.Exception ex)
            {
                if (showDebugLogs) Debug.LogWarning($"[Retrieval] {gameObject.name}: endDecorator Instantiate failed -> {ex.Message}");
            }
        }

        // 1) ì§§ì€ ì•ë‹¹ê¹€
        float stepDuration = 0.08f;
        float t = 0f;
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: pull start pos={startPos} pullPos={pullPos}");
        while (t < stepDuration)
        {
            t += Time.deltaTime;
            float f = Mathf.Clamp01(t / stepDuration);
            transform.position = Vector3.Lerp(startPos, pullPos, f);
            transform.rotation = startRot;
            if (lr != null)
            {
                lr.SetPosition(0, collector.position);
                lr.SetPosition(1, transform.position); // í•­ìƒ stake ìœ„ì¹˜ë¥¼ ë¼ì¸ ëìœ¼ë¡œ
            }
            if (endDec != null) endDec.transform.position = transform.position;
            yield return null;
        }
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: pull end pos={transform.position}");

        // 2) íˆíŠ¸ ì´í™íŠ¸(íˆíŠ¸ìŠ¤íƒ‘ + ì¹´ë©”ë¼ ì…°ì´í¬)
        try
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: PlayHitEffect at {transform.position} (hitStop={hitStop}, shake={shake})");
            HitEffectManager.PlayHitEffect(EHitSource.Stake, hitStop, shake, transform.position);
        }
        catch (System.Exception ex)
        {
            if (showDebugLogs) Debug.LogWarning($"[Retrieval] {gameObject.name}: HitEffectManager exception -> {ex.Message}");
        }

        // íˆíŠ¸ìŠ¤íƒ‘ ë™ì•ˆì€ íƒ€ì„ìŠ¤ì¼€ì¼ ë³€ë™ ê°€ëŠ¥í•˜ë¯€ë¡œ ì‹¤ì‹œê°„ ëŒ€ê¸° ì‚¬ìš©
        if (hitStopSeconds > 0f)
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: waiting hitStopSeconds={hitStopSeconds} (Realtime)");
            yield return new WaitForSecondsRealtime(hitStopSeconds);
        }

        // 2b) íˆíŠ¸ íŒŒí‹°í´ ì¬ìƒ (ì„ì‹œ ì»´í¬ë„ŒíŠ¸ ìƒì„±)
        try
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: spawning HitParticleEffect at {transform.position}");
            GameObject tmp = new GameObject($"Temp_HitParticle_{GetInstanceID()}");
            var hpe = tmp.AddComponent<HitParticleEffect>();
            hpe.PlayHitParticle(transform.position);
            Destroy(tmp, 2.0f);
        }
        catch (System.Exception ex)
        {
            if (showDebugLogs) Debug.LogWarning($"[Retrieval] {gameObject.name}: HitParticleEffect exception -> {ex.Message}");
        }

        // 3) í”Œë ˆì´ì–´ë¡œ í¡ìˆ˜ ì• ë‹ˆë©”ì´ì…˜
        t = 0f;
        Vector3 midStart = transform.position;
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: start moveToPlayerDuration={moveToPlayerDuration} from {midStart} to {collector.position}");
        while (t < moveToPlayerDuration)
        {
            t += Time.deltaTime;
            float f = Mathf.Clamp01(t / moveToPlayerDuration);
            transform.position = Vector3.Lerp(midStart, collector.position, f);
            transform.rotation = startRot;
            if (lr != null)
            {
                lr.SetPosition(0, collector.position);
                lr.SetPosition(1, transform.position); // stakeê°€ í•­ìƒ ë¼ì¸ ëì— ë¶™ìŒ
            }
            if (endDec != null) endDec.transform.position = transform.position;
            yield return null;
        }
        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: reached player pos={transform.position}");

        // 4) ì„  ì •ë¦¬ (ë°˜ë“œì‹œ CompleteRetrieval ì „ì— ìˆ˜í–‰)
        if (lrGo != null)
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: destroying line {lrGo.name}");
            Destroy(lrGo);
        }
        if (endDec != null)
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: destroying end decorator {endDec.name}");
            Destroy(endDec);
        }

        // 5) ë„ì°© ì²˜ë¦¬ -> ê¸°ì¡´ CompleteRetrieval ì¬ì‚¬ìš©
        try
        {
            if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: calling CompleteRetrieval()");
            CompleteRetrieval();
        }
        catch (System.Exception ex)
        {
            if (showDebugLogs) Debug.LogWarning($"[Retrieval] {gameObject.name}: CompleteRetrieval exception -> {ex.Message}");
            try
            {
                UnregisterFromHost();
                if (AttackManager.Instance != null) AttackManager.Instance.ReleaseStake(gameObject);
                else Destroy(gameObject);
            }
            catch { }
        }

        if (showDebugLogs) Debug.Log($"[Retrieval] {gameObject.name}: END");
        yield break;
    }

    public EnemyController GetHostEnemy()
    {
        return currentHostEnemy;
    }
}